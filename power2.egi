#!/usr/bin/env egison

;$ echo 'print pow(3, 21)' | python
;10460353203

;$ echo 'print pow(3, 21, 321)' | python
;33

;$ echo 'print pow(63437, 3935969939, 20628)' | python
;18461

; (define $main
;   (lambda [$args] (display (power-modulo 3 21 2))))

(define $main
  (lambda [$args] (let {[$number (read (nth 1 args))]}
                   (do {
                       (if (prime-mr? number) (print (show number)) (print "Non prime"))
                       ; (display (prime-mr? (read $args)))
                       ; (display (odd-factor 43152))
                       ; (display (prime-mr? 2))
                       ; (display (prime-mr? 2))
                       ; (display (prime-mr? 1))
                       ; (display (prime-mr? 2))
                       ; (display (prime-mr? 4123512))
                       ; (display (prime-mr? 4123511))
                       ; (display (power-modulo 3 21 321))
                       ; (display (power-modulo 63437 3935969939 20628))
                       ; (display (power2 3 21))
                       ; (display (power a 5))
                       ; (display (power2 a 5))
                       }
                    ))))

(define $prime-mr?
  (lambda [$n]
    (match (abs n) integer
      {
       [,2 #t]
       [,1 #f]
       [?even? #f]
       [_ (prime-search n (odd-factor (- n 1)) 20)]
       }
      )))

(define $prime-search
  (lambda [$n $odd $count]
    (match count integer
      {[,0 #t]
      [_ (let* {
           [$a (pure-rand 1 (- n 2))]
           [[$t $y] (prime-search2 n odd (power-modulo a odd n))]
           }
           (if (and (not (eq? y (- n 1))) (even? t))
               #f (prime-search n odd (- count 1))))]})))

; Re-define and
(define $cand
  (cambda $args
           (eq? (unique/m bool args) {#t})))

; input n t y
; return {t y}
(define $prime-search2
  (lambda [$n $t $y]
    (if (cand (ne? t (- n 1)) (ne? y 1) (ne? y (- n 1)))
         (prime-search2 n (* t 2) (power-modulo y 2 n))
         [t y])))

(define $odd-factor
  (lambda [$n]
    (match n integer
      {[?odd? n]
       [_ (odd-factor (quotient n 2))]
       })))

(define $power-modulo
  (lambda [$x $n $z]
    (match n integer
      {[,1 x]
       [?even? (let {[$y (power-modulo x (quotient n 2) z)]}
                 (modulo (* y y) z))]
       [?odd? (let {[$y (power-modulo x (quotient n 2) z)]}
                (modulo (* (* y y) x) z))]})))

(define $power2
  (lambda [$x $n]
    (match n integer
      {[,1 x]
       [?even? (let {[$y (power2 x (quotient n 2))]}
                 (* y y))]
       [?odd? (let {[$y (power2 x (quotient n 2))]}
                (* (* y y) x))]})))
